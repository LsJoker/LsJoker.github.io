<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript 原型（面向对象）]]></title>
    <url>%2F2017%2F08%2F30%2FJs%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[web设计最重要的事网页脚本编程，那么Js就是最终要的工具。什么是Js？即JavaScript，一种专为网页交互设计的语言，且面向对象。 什么是面向对象？？当然不是下图的面向对象哈 什么是面向对象？？ 面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是种具有对象概念的程序编程范型，同时也是一种程序开发的方法。它可能包含数据、属性、代码与方法。对象则指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。面向对象是一种思维方法面向对象是一种编程方法面向对象并不只针对某一种编程语言 面向对象的三大特征： 封装也就是把客观事物封装成抽象的类或具体的对象，并且类或对象可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承可以让某个类型的对象获得另一个类型的对象的属性的方 多态不同实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。 面向对象的优点： 结构清晰，程序便于模块化，结构化，抽象化，更加符合人类的思维方式； 封装性，将事务高度抽象，从而便于流程中的行为分析，也便于操作和自省； 容易扩展，代码重用率高，可继承，可覆盖； 实现简单，可有效地减少程序的维护工作量，软件开发效率高。 缺点是： 效率低，面向对象在面向过程的基础上高度抽象，从而和代码底层的直接交互非常少机会，从而不适合底层开发和游戏甚至多媒体开发； 复杂性，对于事务开发而言，事务本身是面向过程的，过度的封装导致事务本身的复杂性提高。 JavaScript的面向对象在JavaScript中（ES6之前）没有类的概念，那在JavaScript中怎么才能new出一个对象呢。JavaScript是基于原型的面向对象，在JavaScript中一切皆对象。就生成对象的方法就有很多种，下面将一一介绍。 1.用字面量来创建一个对象: var person = { name:&quot;孙大神&quot;, age:&quot;1000&quot;, seeBook:function(){ alert(&quot;看书&quot;); } } name : “孙大神” 一个键值对表示JavaScript对象的一个属性。 name是属性名， “孙大神” 属性值。 属性可以是任意类型的。可以包括简单数据类型，可以是对象，当然包括函数，一切函数都是对象。 当一个属性的值是函数的时候，我们更喜欢说这个属性为方法。 我们一般说person对象具有了一个方法seeBook. 将来访问seeBook的时候，也和调用一个函数是一样的，如 person.seeBook(); 接下来先看一下怎么访问对象的属性或方法。访问一个对象的属性，我们可以直接通过 对象.属性名 和 对象[属性名] 来访问。 console.log(person.name);//访问person对象的 name属性值 person.age = 555;//修改person对象的 age 属性 person.seeBook();//既然是调用方法(函数) 则一定还要加()来表示方法的调用,上文提过 alert(person[&quot;name&quot;]);//等同于alert(person.name); 注意：两种使用方式有一些不同的地方：对象.属性名的方式，只适合知道了属性的名字，可以直接写。如： person.age 。如果属性名是个变量，则这种方法无效， 对象.变量名则会出现语法错误。对象[属性名]，这种方式使用无限制。如果是字符串常量，则应该用””引起来，如果是变量，可以直接使用。 对象的创建方式1.使用关键字new来创建，new Object(),注意O大写： &lt;script type=&quot;text/javascript&quot;&gt; //使用object创建一个对象 完全等同于 var person = {}; var person = new Object(); //给对象添加属性 person.name = &quot;猪八戒&quot;; //给对象添加方法 person.look = function () { alert(&quot;肥头大耳朵~~~&quot;) }； &lt;/script&gt; 当然这种方式是很基础的一种，读者可以想一想，当你需要创建很多相似的对象的时候我们该怎么办？ 2.工厂模式：顾名思义，是像工厂一样的批量生产对象，这就可以解决1中留下的问题： &lt;script type=&quot;text/javascript&quot;&gt; function createPerson(name, age, job) { var per = new Object(); per.name = name; per.age = age; per.look = look; per.sayName = function() { alert(this.name); }; return per; } var person1 = createPerson(&quot;孙悟空&quot;, 29, &quot;猴子&quot;); var person2 = createPerson(&quot;猪八戒&quot;, 27, &quot;肥头大耳&quot;); &lt;/script&gt; 发现问题了吗？这种方式虽然很好的解决了对象的批量创建，但是没有解决对象识别问题（即无法分辨一个对象的类型） 3.构造函数模式：这种模式，创建一些原生对象的时候，比如Array、Object就是调用的他们的构造函数。不废话，直接上代码： &lt;script type=&quot;text/javascript&quot;&gt; function Person (name, age, sex) { this.name = name; this.age = age; this.look = look; this.description = function () { alert(this.name + &quot;是&quot; + this.look); } } var p1 = new Person(&quot;孙悟空&quot;, 30, &quot;猴子&quot;); p1.description(); //孙悟空是猴子 var p1 = new Person(&quot;猪八戒&quot;, 30, &quot;肥头大耳朵&quot;); p1.description(); //猪八戒是肥头大耳朵 alert(p1 instanceof Person); //true，是它的实例 &lt;/script&gt; 使用构造函数创建对象，必须使用关键字new，后面跟着构造函数的名，根据需要传入相应的参数。 用构造函数的原理： 创建出来一个新的对象，将构造函数的作用域赋给新对象。意味着这个时候 this就代表了这个新对象。 执行构造函数中的代码。 在本例中就是给新对象添加属性，并给属性初始化值。 构造函数执行完毕之后，默认返回新对象。 所以外面就可以使用个刚刚创建的新对象了。 构造函数与普通函数的关系： 他们都是函数。构造函数也是函数，也可以像普通的函数一样进行调用。 做普通函数调用的时候，因为没有创建新的对象，所以this其实指向了window对象； 构造函数和普通函数仅仅也仅仅是调用方式的不同。也就是说，随便一个函数你如果用new 的方式去使用，那么他就是一个构造函数。为了区别开来，如果一个函数想作为构造函数，作为国际惯例，最好把这个函数的首字母大写，这是代码书写规范，希望大家都能写出漂亮的代码。 如果文章对你有所帮助，那么太好了！❤由于本人水平有限，如有错误，欢迎大家指正。如果你在操作过程中发现一些没有讲到的错误或者问题，欢迎微信或者微博留言，一起探讨，共同学习进步！]]></content>
      <categories>
        <category>原型</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型]]></title>
    <url>%2F2017%2F08%2F29%2F%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[上一篇文章中介绍了JS中的面向对象，如果还不是很了解的话建议重回上一篇文章传送门。这篇文章主要介绍JS的面向对象中继承的原理。 一、什么是原型JavaScript的继承就是基于原型的继承。所以想要学好JavaScript的面向对象就必须要学好JavaScript中的原型。 1. 原型对象在JavaScript中，我们创建一个函数A(就是声明一个函数), 那么浏览器就会在内存中创建一个原型对象B，而且每个函数都默认会有一个属性 prototype 指向了这个对象( 即：prototype的属性的值是这个对象 )。这个对象B就是函数A的原型对象，简称函数的原型。这个原型对象B 默认会有一个属性 constructor 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。 1234567891011121314&lt;body&gt; &lt;script type="text/javascript"&gt; /* 声明一个函数，则这个函数默认会有一个属性叫 prototype 。而且浏览器会自动按照一定的规则 创建一个对象，这个对象就是这个函数的原型对象，prototype属性指向这个原型对象。这个原型对象 有一个属性叫constructor 指向了这个函数 注意：原型对象默认只有属性：constructor。其他都是从Object继承而来，暂且不用考虑。 */ function Person () &#123; &#125; &lt;/script&gt;&lt;/body&gt; 上面声明了Person函数之后，浏览器做下图一样的处理。 2. 使用构造函数创建对象上一篇文章中已经介绍过了怎么使用构造函数创建对象了。这里主要是介绍一下使用构造函数创建对象时的一些细节。 当把一个函数作为构造函数 (理论上任何函数都可以作为构造函数) 使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性[[prototype]]，来指向了构造函数的原型对象。 这个不可见的属性我们一般用”[[ ]]”来表示，只是这个属性没有办法直接访问到。 直接上代码：123456789101112&lt;body&gt; &lt;script type="text/javascript"&gt; function Person () &#123; &#125; /* 利用构造函数创建一个对象，则这个对象会自动添加一个不可见的属性 [[prototype]], 而且这个属性 指向了构造函数的原型对象。 */ var p1 = new Person(); &lt;/script&gt;&lt;/body&gt; 这是的原理图就要变成下图了。 从上面的图示中可以看到，创建p1对象虽然使用的是Person构造函数，但是对象创建出来之后，这个p1对象其实已经与Person构造函数没有任何关系了，p1对象的[[ prototype ]]属性指向的是Person构造函数的原型对象。 如果使用new Person()创建多个对象，则多个对象都会同时指向Person构造函数的原型对象。我们可以手动给这个原型对象添加属性和方法，那么p1,p2,p3…这些对象就会共享这些在原型中添加的属性和方法。 如果我们访问p1中的一个属性name，如果在p1对象中找到，则直接返回。如果p1对象中没有找到，则直接去p1对象的[[prototype]]属性指向的原型对象中查找，如果查找到则返回。(如果原型中也没有找到，则继续向上找原型的原型—原型链。 后面再讲)。 如果通过p1对象添加了一个属性name，则对p1对象来说就屏蔽了原型中的属性name。 换句话说：在p1中就没有办法访问到原型的属性name了。 通过p1对象只能读取原型中的属性name的值，而不能修改原型中的属性name的值。 p1.name = “李四”; 并不是修改了原型中的值，而是在p1对象中给添加了一个属性name。 12345678910111213141516171819202122232425262728&lt;script type="text/javascript"&gt; function Person() &#123;&#125; // 可以使用Person.prototype 直接访问到原型对象 //给Person函数的原型对象中添加一个属性 name并且值是 "张三" Person.prototype.name = "张三"; Person.prototype.age = 20; var p1 = new Person(); /* 访问p1对象的属性name，虽然在p1对象中我们并没有明确的添加属性name，但是 p1的 [[prototype]] 属性指向的原型中有name属性，所以这个地方可以访问到属性name 就值。 注意：这个时候不能通过p1对象删除name属性，因为只能删除在p1中删除的对象。 */ alert(p1.name); // 张三 var p2 = new Person(); alert(p2.name); // 张三 都是从原型中找到的，所以一样。 alert(p1.name === p2.name); // true // 由于不能修改原型中的值，则这种方法就直接在p1中添加了一个新的属性name，然后在p1中无法再访问到 //原型中的属性。 p1.name = "李四"; alert("p1：" + p1.name); // 由于p2中没有name属性，则对p2来说仍然是访问的原型中的属性。 alert("p2:" + p2.name); // 张三&lt;/script&gt; 这时候的原理图如下： 二、组合使用原型模型和构造函数模型创建对象1. 原型模型创建对象的缺陷原型中的所有的属性都是共享的。也就是说，用同一个构造函数创建的对象去访问原型中的属性的时候，大家都是访问的同一个对象，如果一个对象对原型的属性进行了修改，则会反映到所有的对象上面。 但是在实际使用中，每个对象的属性一般是不同的。张三的姓名是张三，李四的姓名是李四。 ​ 但是，这个共享特性对方法(属性值是函数的属性)又是非常合适的。所有的对象共享方法是最佳状态。 2. 使用构造函数模型创建对象的缺陷在构造函数中添加的属性和方法，每个对象都有自己独有的一份，大家不会共享。这个特性对属性比较合适，但是对方法又不太合适。因为对所有对象来说，他们的方法应该是一份就够了，没有必要每人一份，造成内存的浪费和性能的低下。 3. 解决的方法1234567891011121314&lt;script type="text/javascript"&gt; function Person() &#123; this.name = "李四"; this.age = 20; this.eat = eat; &#125; function eat() &#123; alert("吃完东西"); &#125; var p1 = new Person(); var p2 = new Person(); //因为eat属性都是赋值的同一个函数，所以是true alert(p1.eat === p2.eat); //true&lt;/script&gt; 但是上面的这种解决方法具有致命的缺陷：封装性太差。使用面向对象，目的之一就是封装代码，这个时候为了性能又要把代码抽出对象之外，这是反人类的设计。 4. 使用组合模式解决上述两种缺陷原型模式适合封装方法，构造方法模式适合封装属性，综合两种模式的优点就有了组合模式。123456789101112131415161718192021&lt;script type="text/javascript"&gt; //在构造方法内部封装属性 function Person(name, age) &#123; this.name = name; this.age = age; &#125; //在原型对象内封装方法 Person.prototype.eat = function (food) &#123; alert(this.name + "爱吃" + food); &#125; Person.prototype.play = function (playName) &#123; alert(this.name + "爱玩" + playName); &#125; var p1 = new Person("李四", 20); var p2 = new Person("张三", 30); p1.eat("苹果"); p2.eat("香蕉"); p1.play("志玲"); p2.play("凤姐");&lt;/script&gt; 组合模式，也并非完美无缺，有一点也是感觉不是很完美。把构造方法和原型分开写，总让人感觉不舒服，应该想办法把构造方法和原型封装在一起，所以就有了动态原型模式。 5. 动态原型模式动态原型模式把所有的属性和方法都封装在构造方法中，而仅仅在需要的时候才去在构造方法中初始化原型，又保持了同时使用构造函数和原型的优点。123456789101112131415161718192021&lt;script type="text/javascript"&gt; //构造方法内部封装属性 function Person(name, age) &#123; //每个对象都添加自己的属性 this.name = name; this.age = age; /* 判断this.eat这个属性是不是function，如果不是function则证明是第一次创建对象， 则把这个funcion添加到原型中。 如果是function，则代表原型中已经有了这个方法，则不需要再添加。 perfect！完美解决了性能和代码的封装问题。 */ if(typeof this.eat !== "function")&#123; Person.prototype.eat = function () &#123; alert(this.name + " 在吃"); &#125; &#125; &#125; var p1 = new Person("志玲", 40); p1.eat(); &lt;/script&gt; 建议以后使用动态原型模式。他解决了组合模式的封装不彻底的缺点。 希望文章能对你的技术有帮助。由于本人水平有限，如有错误，欢迎大家指正。如果你在操作过程中发现一些没有讲到的错误或者问题，欢迎在评论留言，一起探讨，共同学习，共同进步！]]></content>
      <categories>
        <category>原型</category>
      </categories>
      <tags>
        <tag>理解原型</tag>
      </tags>
  </entry>
</search>
